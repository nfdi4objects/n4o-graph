[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "NFDI4Objects Knowledge Graph (TA5)",
    "section": "",
    "text": "Eine erste Version der Cypher-API des Property-Graphen ist jetzt verfügbar!\n\n\n\nAn dieser Stelle entsteht ein Handbuch für die Verwaltung und Nutzung des Knowledge Graphen von NFDI4Objects (TA5). Der Zugriff auf die Inhalte des Knowledge Graphen ist Kapitel Benutzung beschrieben. Hintergründe und Details finden sich im Grundlagen-Kapitel und in der Beschreibung der Systemarchitektur.\nDer Knowledge Graph besteht im Kern aus einem Triple-Store, in denen Daten aus verschiedenene Quellen zusammengeführt werden und per SPARQL-Schnittstelle abgefragt werden können. Darüber hinaus sind weitere Schnittstellen geplant, darunter ein Query-Builder und einen Graph-Browser. Forschungsdaten-Anwendungen können auf den Knowledge Graphen zugreifen und ausgefeiltere Recherchemöglichkeiten bieten.\nDer aktuelle Stand des Property Graphen ist über ein Dashboard einsehbar.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Einleitung</span>"
    ]
  },
  {
    "objectID": "basics.html",
    "href": "basics.html",
    "title": "Grundlagen",
    "section": "",
    "text": "Knowledge Graph\nIn einem Knowledge Graph (auch Wissensgraph) sind Informationen strukturiert und stark miteinander vernetzt gespeichert. Ein Beispiel hierfür ist ein Netzwerk aus Personen, die durch Verwandschaft und andere Beziehungen miteinander verknüpft sind. Jeder Graph besteht aus Knoten und Kanten. So lassen sich beispielsweise Personen durch Knoten und Beziehungen durch Kanten repräsentieren.\nWeitere Details hängen von der technischen Umsetzung des Knowledge Graphen ab. Die beiden am häufigsten verwendeten Datenbankmodelle sind Property-Graphen und das RDF-Datenmodell mit Triple Stores. Darüber hinaus gibt es einige Knowledge Graphen mit eigenem Datenbankmodell, beispielsweise Wikidata auf Grundlage von des Wikibase-Modells.\nDie Inhalte eines Knowledge Graphen besteht aus einem Schema, optional einigen Vokabularen und dem Datenbestand als eigentlichem Datenbankinhalt. Einzelne “Datensätze” gibt es aufgrund der Graphstruktur nicht.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen</span>"
    ]
  },
  {
    "objectID": "basics.html#datenbankmodelle",
    "href": "basics.html#datenbankmodelle",
    "title": "Grundlagen",
    "section": "Datenbankmodelle",
    "text": "Datenbankmodelle\n\nProperty Graph\nProperty-Graphen dienen der Strukturierung, Speicherung und Auswertung vernetzter Daten. Die Daten werden dabei nicht in tabellarischer Form (wie bei einer Tabellenkalkulation oder bei SQL) oder in hierarchischer Form (wie bei XML) sondern in Form eines Graphen gespeichert. Die Knoten und Kanten des Graphen können jeweils Labels (Typen) haben und mit Eigenschaften versehen sein. Zur Abfrage von Property-Graphen dient die Sprache Cypher. Eine genauere Erklärung liefert der Artikel Property-Graphen: eine kurze Einführung.\n\n\n\n\n\n\nTipp\n\n\n\nBeispiele von Property-Graphen werden in diesem Handbuch im Property Graph Exchange Format (PG) dargestellt.\n\n\n\n\nTriple Store\nEin Triple Store ist eine Graphendatenbank in der Daten dem RDF-Modell nach in Form von so genannten Triplen gespeichert werden. Jedes Tripel entspricht in der Regel einer Kante im Graphen und besteht aus Subjekt, Prädikat und Objekt. Als Abfragesprache für RDF-Daten in Triple Stores dient SPARQL.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen</span>"
    ]
  },
  {
    "objectID": "basics.html#datenbankinhalt",
    "href": "basics.html#datenbankinhalt",
    "title": "Grundlagen",
    "section": "Datenbankinhalt",
    "text": "Datenbankinhalt\n\nSchema\nDas Datenbankschema oder Datenmodell eines Knowledge Graphen bestimmt welche Arten von Knoten, Kanten und weiterer Inhalte im Graph enthalten sein dürfen. Da sich die Datenbankmodelle von Property Graph und Triple Store unterscheiden, gibt es für beide jeweils ein eigenes Schema. Beide Schemas basieren allerdings auf dem gemeinsamen abstrakten Datenmodell CIDOC-CRM. Details zu den Schemas finden sich im Kapitel Datenbankschema.\n\n\n\n\n\n\nBeispiel\n\n\n\nIm Schema ist beispielsweise vorgegeben, dass es für Messungen Knoten der Klasse E16_Measurement und für Zeiträume Knoten der Klasse E52_Time_Span gibt.\n\n\nNeben dem Schema von Graphdatenbanken gibt Schemas zur Validierung der Datenformate gelieferter Daten.\n\n\nDatenbestand\nDer Datenbestand ist der eigentliche Inhalt des gemeinsamen Knowledge Graphen von NFDI4IObjekts. Er wird im Gegensatz zu Schema und Vokabularen laufend durch Lieferungen von Sammlungen Forschungsdaten aktualisiert, die in den Graphen integriert werden.\n\n\nVokabular\nVokabulare sind vorgegebene Listen von Entitäten oder Werten. Sie sind in Form von Identifikatoren, Datentypen und/oder Knoten und Kanten zwar Teil des Knowledge-Graphen gehören aber eher nicht zum eigentlichen Datenbestand. Vokabulare werden nur in unregelmäßign Abständen und zentral aktualisiert. Sie dürfen nicht durch Lieferungen von Sammlungen überschrieben werden. Weitere Informationen finden sich in den Kapiteln zu Vokabularen und zu Mappings.\n\n\n\n\n\n\nBeispiel\n\n\n\nHäufig verwendete Vokabulare sind die Gemeinsame Normdatei (GND), das Klassifizierungssystem Iconclass und die Normdateien des Getty Research Institute. Darüber hinaus gibt es zahlreiche Spezial-Vokabulare wie zum Beispiel die Hornbostel-Sachs-Klassifikation der Musikinstrumente.\n\n\n\n\nSammlung\nDer Datenbestand des Knowledge Graphen von NFDI4IObjekts ist in so genannte Sammlungen unterteilt. Einige Sammlungen bestehen aus einzelnen Datensätzen, andere aus einer zusammengefassten Lieferung von Daten. Weitere Informationen zu Sammlungen und Lieferungen finden sich im Kapitel Datenquellen.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen</span>"
    ]
  },
  {
    "objectID": "basics.html#datenformate",
    "href": "basics.html#datenformate",
    "title": "Grundlagen",
    "section": "Datenformate",
    "text": "Datenformate\nZur Integration in den Datenbestand des Knowledge Graphen können Daten grundsätzlich in LIDO oder in RDF geliefert werden. Darüber hinaus gibt es spezielle Formate für Vokabulare und Mappings.\n\nLIDO\nLightweight Information Describing Objects (LIDO) ist ein XML-Format aus dem Museumsbereich (siehe LIDO in der Formatdatenbank).\n\n\nRDF\nRDF-Daten können in verschiedenen Serialisierungen vorkommen, die sich verlustfrei ineinander überführen lassen (siehe RDF in der Formatdatenbank). Im Gegensatz zum allgemeinen Graph-Daten eines Property Graphen enthalten RDF-Daten global eindeutige URIs als Identifikatoren. Außerdem lassen sich RDF-Daten aus unterschiedlichen Quellen immer zusammenführen. Sofern kein einheitliches Schema verwendet wird, ist das Ergebnis allerdings uneinheitlich.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>Grundlagen</span>"
    ]
  },
  {
    "objectID": "sources.html",
    "href": "sources.html",
    "title": "Datenquellen",
    "section": "",
    "text": "Anforderungen an Datenlieferungen",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "sources.html#anforderungen-an-datenlieferungen",
    "href": "sources.html#anforderungen-an-datenlieferungen",
    "title": "Datenquellen",
    "section": "",
    "text": "Lieferung ausschließlich in RDF oder als XML Lightweight Information Describing Objects (LIDO)\nZur Integration von RDF-Daten in den Property Graphen muss das CIDOC Concept Reference Modell (CRM) verwendet werden oder die verwendeten Ontologien auf CRM gemappt sein\nBeschreiben einer Minimalmenge an Datenfeldern, um eine bestimmte Datenqualität zu erfüllen und durchsuchbare Datensets zu erzeugen; das Minimaldatenset und die ObjectOntology als dessen RDF-serialisrung werden im Konsortium noch erarbeitet.\nVerwendung von etablierten Vokabularen oder zumindest URIs statt Freitextfeldern\nVersionierung der Metadaten, sinnvoll bei Aktualisierung des Datenbestands für den KG\nAngaben von Rechteinhabern, Herausgeber und Lizenzen (bspw. Creative Commons) für eine Nachnutzung\nVerwendung von Normdaten-URI zur eindeutigen Zuweisung von Personen, Geografika u. s. w. (bspw. GND, VIAF, Wikidata, Geonames, historischen Gazeteers, …)\nWeitere Daten der unterstützten Terminologien und Ontologien werden herausgefiltert und gesondert eingespielt.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "sources.html#beispiele",
    "href": "sources.html#beispiele",
    "title": "Datenquellen",
    "section": "Beispiele",
    "text": "Beispiele\n\nDatenlieferung der Klassik Stiftung Weimar\n\naktuell noch LIDO 1.0, Export orientiert an LIDO für die Deutsche Digitale Bibliothek\nAuszug aus der Museumsdatenbank, einer KSW-eigenentwickelten Oracle-Datenbank, die für Portallieferungen einen LIDO-Export anbietet\nca. 30.000 Datensätze, die auch im Online-Katalog “Digitale Sammlungen der Museen” der Klassik Stiftung Weimar veröffentlicht sind, werden verwendet (mdb_datendump_n4o_export_true), ohne zugehörige Bilddateien (digitale Repräsentationen der Objekte)\ntestweise nach Sprint im Juli ca. 30 Datensätze der grafischen Sammlung gesendet, im für den August terminierten Sprint 2 wird die ereignisbasierte Ausgabe angepasst",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Datenquellen</span>"
    ]
  },
  {
    "objectID": "crm.html",
    "href": "crm.html",
    "title": "CIDOC-CRM",
    "section": "",
    "text": "Das CIDOC Conceptual Reference Model (CRM) ist ein abstraktes Datenmodell zur Modellierung von Informationen aus dem Kulturbereich. CRM ist Grundlage verschiedener Datenformate und Datenbanken. Insbesondere bildet es auch die Grundlage der Ontologie des Knowledge Graphen in Form des Datenbankschema.\n\nUmfang\nFolgende Bestandteile des CRM werden unterstützt:\n\nCRM-Klassen und Properties aller bisherigen CRM-Versionen\nCRM-Erweiterungen CRMarchaeo, CRMsci und LRMoo\n\nAndere Ontologien müssen zur Integration in das gemeinsame Datenmodell auf CRM gemappt werden.\n\n\nWeitere Informationen\n\nCIDOC-CRM Homepage\nWikipedia-Eintrag zu CRM",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>CIDOC-CRM</span>"
    ]
  },
  {
    "objectID": "schema.html",
    "href": "schema.html",
    "title": "Datenbankschema",
    "section": "",
    "text": "Modellierung",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenbankschema</span>"
    ]
  },
  {
    "objectID": "schema.html#modellierung",
    "href": "schema.html#modellierung",
    "title": "Datenbankschema",
    "section": "",
    "text": "Entitäten und Knoten\nKnoten im Property Graphen erhalten als Knoten-Label die entsprechenden CRM-Klassen. Dabei werden Leerzeichen und Sonderzeichen durch Unterstrich ersetzt\n\n\n\n\n\n\nBeispiele\n\n\n\nEntitäten der CRM-Klasse E16 Measurement werden Knoten mit dem Label E16_Measurement. Entitäten der CRM-Klasse E22 Human-Made Object werden Knoten mit dem Label E22_Human_Made_Object\n\n\nZwischenzeitlich gelöschte und umbenannte Klassen können weiterhin verwendet werden, allerdings werden diese durch Expansion auf die neueste Form gemappt.\n\n\nElementare Datentypen\nDie folgende CRM-Klassen für elementare Datentypen werden nicht als Knoten-Label verwendet. Ihre Instanzen werden im Datenmodell stattdessen als Property-Werte abgebildet:\n\nE59 Primitive Value\nE60 Number für Zahlen\nE62 String für Zeichenketten\n\nInstanzen der folgenden CRM-Klassen werden ebenfalls wenn möglich nicht als Knoten sondern als Property-Werte abgebildet. Anderenfalls erfolgt die Expansion nur über die übergeordnete Klasse E41 Appellation:\n\nE61 Time Primitive für Datums- und Zeitangaben\nE94 Space Primitive für Koordinaten\n\n\n\nRelationen und Kanten\nCRM-Properties (nicht zu verwechseln mit Eigenschaften im Property-Graph Datenbankmodell) werden im Property-Graphen durch Kanten-Label modelliert.\n\n\n\n\n\n\nExpansion von Kanten-Label ist noch nicht umgesetzt!\n\n\n\n\n\n\n\n\n\nInverse CRM-Properties sind noch nicht berücksichtigt!\n\n\n\nEine Ausnahme bilden die folgenden CRM-Properties für elementare Datentypen, die stattdessen zu Property-Keys werden (siehe folgender Abschnitt).\n\n\nProperties\nFolgende CRM-Properties werden im Property-Graphen durch Knoten-Properties modelliert:\n\n\n\nCRM-Property\nProperty-Key\nDatentyp\n\n\n\n\nP3 has note\nP3_has_note\nZeichenkette\n\n\nP57 has number of parts\nP57_has_number_of_parts\nZahl\n\n\nP79 beginning is qualified by\nP79_beginning_is_qualified_by\nZeichenkette\n\n\nP80 end is qualified by\nP80_end_is_qualified_by\nZeichenkette\n\n\nP90 has value\nP90_has_value\nZahl)\n\n\nP168 place is defined by (defines place)\nP168_place_is_defined_by\nKoordinate\n\n\nP170 defines time (time is defined by)\nP170i_time_is_defined_by (inverse Relation!)\nDatums-/Zeitangabe\n\n\nP171 at some place within\nP171_at_some_place_within\nKoordinate\n\n\nP172 contains\nP172_contains\nKoordinate\n\n\nP190 has_symbolic_content\nP190_has_symbolic_content\nZeichenkette\n\n\n\n\n\n\n\n\n\nDie Property-Keys werden möglicherweise noch umbenannt, um zu lange Namen zu vermeiden!\n\n\n\n\n\n\n\n\n\nBeispiel\n\n\n\nd1 :E54_Dimension P90_has_value:12   # Wert 12 als Property\nd1 -&gt; u1 :P90_has_unit               # Einheit u1 (hier nicht weiter definiert) \n\n\nDarüber hinaus gibt es einige besondere Property-Keys, deren möglicher Einsatz noch diskutiert wird:\n\ncID\ncollection\nvalue\nlang\ntype\npref\nformatResource\nsortorder\nsource\nuri\n\n\n\nExpansion\nEntsprechend der CRM-Klassenhierarchie erhalten alle Knoten ausgehend von ihren Labels jeweils zusätzlich als Label die CRM-Kürzel der eigenen und aller übergeordneten Klassen.\n\n\n\n\n\n\nBeispiele\n\n\n\nKnoten mit dem Label E16_Measurement erhalten zusätzlich die Label E16 sowie die übergeordneten Klassen E13 (Attribute Assignment), E7 (Activity), E5 (Event), E4 (Period), E2 (Temporal Entity) und E92 (Spacetime Volume) sowie E1 (CRM Entity).\nEntitäten der CRM-Klasse E22 Man-Made_Object (mit CRM-Version 6.2.7 umbenannt in “E22 Human-Made Object”) werden Knoten mit dem Label E22_Man_Made_Object und erhalten die selben Überklassen wie E22_Human_Made_Object.\nEntitäte der CRM-Klasse E40 Legal-Body werden Knoten mit dem Label E40_Legal_Body aber da die Klasse veraltet ist und stattdessen E74 Group verwendet werden soll, erhalten sie zusätzlich die Label E74 und die selben Überklassen wie E74_Group.\n\n\nDie Anreicherung ergibt sich aus der CRM-Klassenhierarchie:\n\nCIDOC-CRM-Klassen (alle Versionen)\nCIDOC-CRM-Properties (alle Versionen)\nCRM und auf CRM-gemappte Klassen\n\n\n\nOffene Punkte\nDas Datenmodell muss noch erweitert werden um:\n\nIdentifier (für Normdaten-Identifier siehe https://github.com/nfdi4objects/n4o-terminologies)\n\nCREATE CONSTRAINT uri FOR (n:E1) REQUIRE n.uri IS UNIQUE \n\nInformationen über Sammlungen aus denen die Daten und Objekte stammen (siehe https://github.com/nfdi4objects/n4o-databases und https://github.com/nfdi4objects/n4o-rdf-import)\nInformationen über Ontologien und Vokabulare",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenbankschema</span>"
    ]
  },
  {
    "objectID": "schema.html#beispiel",
    "href": "schema.html#beispiel",
    "title": "Datenbankschema",
    "section": "Beispiel",
    "text": "Beispiel\nFolgender in CIDOC-CRM modellierter Teilgraph (in Turtle-Syntax):\n@prefix crm: &lt;http://www.cidoc-crm.org/cidoc-crm/&gt; .\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5af2f810b638d&gt;\n  a crm:E16_Measurement ;\n  crm:P40_observed_dimension &lt;http://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41&gt; .\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41&gt;\n  a crm:E54_Dimension ;\n  crm:P2_has_type &lt;http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc30b&gt; ;\n  crm:P91_has_unit &lt;http://objekte-im-netz.fau.de/palaeo/id/5b353177d6480&gt;\n  crm:P90_has_value 2.8 .\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5b353177d6480&gt;\n  a crm:E58_Measurement_Unit ;\n  crm:P48_has_preferred_identifier &lt;http://objekte-im-netz.fau.de/palaeo/id/5b353177d64bc&gt; .\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc30b&gt;\n  a crm:E55_Type .\n  crm:P48_has_preferred_identifier &lt;http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc310&gt; ;\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc310&gt;\n  a crm:E42_Identifier ;\n  crm:P3_has_note \"Höhe (Scan)\" .\n\n&lt;http://objekte-im-netz.fau.de/palaeo/id/5b353177d64bc&gt;\n  a crm:E42_Identifier ;\n  crm:P3_has_note \"cm\" .\n\nwird konvertiert in folgenden Property Graph (in PG Format und als Diagram):\nhttp://objekte-im-netz.fau.de/palaeo/id/5af2f810b638d\n  :E16_Measurement\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5af2f810b638d \n  -&gt; http://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41\n  :P40_observed_dimension\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41\n  :E54_Dimension \n  P90_has_value: 2.8\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41\n  -&gt; http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc30b\n  :P2_has_type\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b3540e7cea41\n  -&gt; http://objekte-im-netz.fau.de/palaeo/id/5b353177d6480\n  :P91_has_unit\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b353177d6480\n  :E58_Measurement_Unit\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b353177d6480\n  -&gt; http://objekte-im-netz.fau.de/palaeo/id/5b353177d64bc\n  :P48_has_preferred_identifier \n\nhttp://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc30b\n  :E55_Type\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc30b\n  -&gt; http://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc310\n  :P48_has_preferred_identifier \n\nhttp://objekte-im-netz.fau.de/palaeo/id/5e3eb2d5dc310\n  :E42_Identifier\n  P3_has_note: \"Höhe (Scan)\"\n\nhttp://objekte-im-netz.fau.de/palaeo/id/5b353177d64bc\n  :E42_Identifier\n  P3_has_note: \"cm\"",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenbankschema</span>"
    ]
  },
  {
    "objectID": "schema.html#vokabulare",
    "href": "schema.html#vokabulare",
    "title": "Datenbankschema",
    "section": "Vokabulare",
    "text": "Vokabulare\nDie konkrete Modellierung und Implementierung ist noch in Arbeit.\nAusgewählte kontrollierte Vokabulare werden zentral in den Property Graphen eingespielt. Das Datenmodell dafür basiert auf CIDOC-CRM und SKOS mit folgenden Bestandteilen:\n\nVokabulare haben die Property uri mit der BARTOC-URI des Vokabulars als Wert und die Label E32_Authority_Document (E32 Authority Document) sowie ConceptScheme zur Markierung, dass sie als Vokabular eingespielt wurden.\nKonzepte haben eine Property uri und können unterschiedliche Label haben. Der allgemein Fall ist E55_Type. (E55 Type). Darüber hinaus erhalten sie das Label Concept zur Markierung, dass sie aus einem Vokabular statt aus einer Lieferung von Forschungsdaten stammen.\nKonzepte werden ihrem Vokabular mit dem Kanten-Label inScheme zugeordnet. Die entsprechende inverse CRM-Property P71 lists wird nicht verwendet.\nKonzepte können mit den Kanten-Labeln broader miteinander verknüpft werden. Die entsprechende CRM-Property P127 has broader term wird nicht verwendet.\nKonzepte können eine interne ID oder Notation haben (Property notation)\nKonzepte sollten Benennungen haben (Property label und labelLang)\n\nDarüber könnten folgende CRM-Bestandteile eine Rolle spielen:\n\nP150 defines typical part of, ein Spezialfall von skos:related.\nP2 has type\nP137 exemplifies die inverse Relation von skos:example.\n\n\n\n\n\n\n\n\nBeispiel\n\n\n\nGND-Datensatz zu “Schleswig-Holstein”:\ngnd :ConceptScheme :E32_Authority_Document             # GND\n  uri: http://bartoc.org/en/node/430\n\nsh :Concept :E55_Type :E42_Identifier            # Schleswig-Holstein\n  uri: https://d-nb.info/gnd/4052692-6\n\nsh -&gt; gnd :inScheme",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Datenbankschema</span>"
    ]
  },
  {
    "objectID": "vocabularies.html",
    "href": "vocabularies.html",
    "title": "Vokabulare",
    "section": "",
    "text": "Vokabulare (auch bekannt als Terminologien oder Normdaten) sind vorgegebene Listen von Entitäten oder Werten, auf die in anderen Daten verwiesen werden kann. Sie sind Teil des Knowledge Graphen, stammen aber nicht aus Datenlieferungen von Sammlungen sondern werden zentral verwaltet.Grundlage für die kontrollierte Verwendung von Vokabularen im Knowledge Graph ist ein Eintrag in BARTOC. Eine Liste von unterstützen oder anderweitig relevanten Vokabularen in NFDI4Objects ist als Teilmenge von BARTOC in einer Übersicht verfügbar. Darin enthalten sind auch Ontologien, die sich in das Datenbankschema des Knowledge Graphen integrieren oder darauf abbilden lassen.\nZur Vereinheitlichung der gelieferten Daten müssen verschiedene Vokabulare aufeinander gemappt werden. Dafür steht unter https://coli-conc.gbv.de/cocoda/nfdi4objects/ eine Instanz der Mapping-Anwendung Cocoda zur Verfügung.",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Vokabulare</span>"
    ]
  },
  {
    "objectID": "usage.html",
    "href": "usage.html",
    "title": "Benutzung",
    "section": "",
    "text": "Cypher-API\nEine öffentliche Entwicklungsversion des Property Graphen kann mit der Abfragesprache Cypher über die API-URL https://graph.nfdi4objects.net/api/cypher abgefragt werden (siehe API-Dokumentation). Unter https://graph.nfdi4objects.net/cypher gibt es eine einfache Weboberfläche zur Formulierung von Abfragen. Eine weitere Einführung mit Beispielen gibt es im Kapitel Cypher-Abfragen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Benutzung</span>"
    ]
  },
  {
    "objectID": "usage.html#sparql-api",
    "href": "usage.html#sparql-api",
    "title": "Benutzung",
    "section": "SPARQL-API",
    "text": "SPARQL-API\nEine öffentliche Entwicklungsversion des Triple-Store kann mit der Abfragesprache SPARQL über die API-URL https://graph.nfdi4objects.net/api/sparql abgefragt werden (siehe API-Dokumentation). Unter https://graph.nfdi4objects.net/sparql gibt es eine einfache Weboberfläche zur Formulierung von Abfragen. Eine weitere Einführung mit Beispielen gibt es im Kapitel SPARQL-Abfragen.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Benutzung</span>"
    ]
  },
  {
    "objectID": "usage.html#datenbankdumps",
    "href": "usage.html#datenbankdumps",
    "title": "Benutzung",
    "section": "Datenbankdumps",
    "text": "Datenbankdumps\n\n\n\n\n\n\nDie Bereitstellung von Datenbankdumps zur lokalen Nutzung von Teilen des Knowledge Graphen ist noch nicht umgesetzt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Benutzung</span>"
    ]
  },
  {
    "objectID": "usage.html#suchoberfläche",
    "href": "usage.html#suchoberfläche",
    "title": "Benutzung",
    "section": "Suchoberfläche",
    "text": "Suchoberfläche\n\n\n\n\n\n\nEine browserbasierte Suchoberfläche (“Rich Metadata Discovery”) mit Möglichkeiten zur interaktiven Abfrage und Datenvisualisierung ist noch nicht umgesetzt.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>Benutzung</span>"
    ]
  },
  {
    "objectID": "cypher.html",
    "href": "cypher.html",
    "title": "Abfragen mit Cypher",
    "section": "",
    "text": "Abfrage-Editor\nviewof cypherEditor = {\n  const mainDiv = html`&lt;div&gt;&lt;div&gt;`\n  const editorDiv = html`&lt;div style=\"border: 1px solid rgb(0, 0, 0);\"&gt;&lt;/div&gt;`\n  const runButton = html`&lt;button&gt;Query&lt;/button&gt;`\n  const errorStatus = html`&lt;span style=\"color: red; margin-left: 1em;\"&gt;&lt;/span&gt;`\n\n  mainDiv.append(editorDiv)\n  mainDiv.append(runButton)\n  mainDiv.append(errorStatus)\n\n  mainDiv.value = undefined\n  yield mainDiv\n\n  let editor = CodeMirror(editorDiv, { mode: \"application/x-cypher-query\" })\n\n  editor.setValue(\"MATCH (m:E16_Measurement) RETURN m LIMIT 10\")\n  editor.setSize(width-20, 200)\n\n  runButton.onclick = async (e) =&gt; {\n    errorStatus.textContent = \"\"\n    mainDiv.value = \n    cypherQuery(editor.getValue())\n      .then(value =&gt; mainDiv.value = value)\n      .catch(e =&gt; { \n        errorStatus.textContent = e\n        mainDiv.value = undefined\n      })\n\n    mainDiv.dispatchEvent(new CustomEvent(\"input\"))\n  }\n\n  return mainDiv\n}\n\ncypherEditor",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Abfragen mit Cypher</span>"
    ]
  },
  {
    "objectID": "cypher.html#cypher-grundlagen",
    "href": "cypher.html#cypher-grundlagen",
    "title": "Abfragen mit Cypher",
    "section": "Kurzeinführung in Cypher",
    "text": "Kurzeinführung in Cypher\nEine vollständige Einführung in die Abfragesprache Cypher liefert das englische Cypher Handbuch.\n\n\n\n\n\n\nDie folgende Kurzeinführung bezieht sich noch nicht auf das Schema des Property Graphen sondern verwendet ein ausgedachtes Beispiel mit Personendaten.\n\n\n\n\nNodes\nKnoten heißen Nodes und werden in runden Klammern definiert.\nMATCH (n:Person {name:'Anna'})\nRETURN n.geboren AS geburtsjahr\nPerson ist ein Label. Labels sind wie Tags und werden genutzt um die Datenbank zu befragen. Eine Node Kann mehrere Labels haben.\nName ist eine Property von Anna. Properties werden in geschweiften Klammern definiert and geben nähere Informationen. Nach Properties kann auch gefragt werden.\nN ist eine Variabel. Auf Variabeln kann weiter verwiesen werden.\nIn diesem Beispiel findet MATCH alle Person Nodes in dem Graph wo die Property name Anna ist und setzt die Variabel n zu dem Ergebnis. n wird dann an RETURN weitergegeben, welche den Wert von einer anderen Property (geboren) dieser Nodes wiedergibt.\n\n\nRelationships\nNodes können mit Relationships verbunden werden. Eine Relationship braucht eine Start Node, eine Ende Node und genau einen Typ. Relationships haben in Cypher einen Pfeil um die Richting zu zeigen. Die Informationen über eine Relationship sind in eckigen Klammern eingeschlossen.\nWährend Nodes mehrere Labels haben können, können Relationships nur einen Typ haben.\nMATCH (:Person {name: 'Anna'})-[r:KENNT WHERE r.seit &lt; 2020]-&gt;(freund:Person)\nRETURN count(r) As zahlAnFreunden\nIn dieser Anfrage findet Match Relationships des Typs KENNT wo die Property seit kleiner als 2020 ist. Außerdem müssen Relationships von einer Person Node mit der Property Anna zu einer anderen Personen Node gehen (wir nennen diese freund). count() wird genutzt um zu zählen wie viele Relationships an die Variabel r in MATCH gebunden wurden somit erhalten wir mit RETURN eine Zahl.\n\n\nPfade\nMATCH (n:Person {name: 'Anna'})-[:KENNT]-{1,5}(freund:Person WHERE n.geboren &lt; freund.geboren)\nRETURN DISTINCT freund.name AS ältereFreunde\nDieses Beispiel nutzt eine quantifizierte Relationship um alle Pfade, die bis zu 5 Schritte entfernt sind, zu finden. Dabei werden nur Relationships des Typs KENNT verwendet. Die Start Node ist Anna und Ende Node sind Personen älter als Anna. Durch DISTINCT wird das gleiche Ergebnis nur einmal ausgegeben.\nMATCH p=shortestPath((:Person {name: 'Anna'})-[:KENNT*1..10]-(:Person {nationalität: 'Kanadier'}))\nRETURN p\nAuch Pfade können einer Variable zugewiesen werden. Hier wird der vollständige Pfad ausgegeben.\n\n\nBeispielabfragen\nFinde Wert, Einheit und Notiz aller Messungen.\nMATCH (n:E16_Measurement)-[:P40_observed_dimension]-&gt;(m:E54_Dimension)-[:P2_has_type]-&gt;(:E55_Type)-[:P48_has_preferred_identifier]-&gt;(l)\nMATCH (m)-[:P91_has_unit]-&gt;(:E58_Measurement_Unit)-[:P48_has_preferred_identifier]-&gt;(o)\nRETURN m.P90_has_value AS value, o.P3_has_note AS unit, l.P3_has_note AS note\n\n\n2.8,cm,Höhe (Scan)",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Abfragen mit Cypher</span>"
    ]
  },
  {
    "objectID": "sparql.html",
    "href": "sparql.html",
    "title": "Abfragen mit SPARQL",
    "section": "",
    "text": "Datenmodell",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Abfragen mit SPARQL</span>"
    ]
  },
  {
    "objectID": "sparql.html#datenmodell",
    "href": "sparql.html#datenmodell",
    "title": "Abfragen mit SPARQL",
    "section": "",
    "text": "Teilgraphen\nDie RDF-Datenbank ist in mehrere Graphen unterteilt:\n\nJede Sammlung von Forschungsdaten wird über eine URI der Form https://graph.nfdi4objects.net/collection/ID identifiziert, beispielsweise https://graph.nfdi4objects.net/collection/4. Die Sammlung kann als ganzes aktualisiert und einzeln oder zusammen mit anderen Inhalten abgefragt werden.\nDer Graph https://graph.nfdi4objects.net/collection/ enthält Informationen über die einzelnen Sammlungen.\nVokabulare und Ontologien sind in eigenen Graphen verwaltet, deren URI der BARTOC-URI des jeweiligen Vokabulars entspricht, beispielsweise http://bartoc.org/en/node/1940 für Wikidata und http://bartoc.org/en/node/1644 für CIDOC-CRM.\nDer Graph https://graph.nfdi4objects.net/terminology/ enthält Informationen über Vokabulare.\n\nSofern kein konkreter Graph angegeben ist, gelten Abfragen über die Gesamtheit aller Graphen.\n\n\nStruktur der Inhalt\nAus den Lieferungen von Sammlungen werden prinzipiell alle syntaktisch korrekten RDF-Daten übernommen. Allerdings werden einige Triples herausgefiltert und einige URIs umgeschrieben, um unnötige Uneinheitlichkeiten zu vermeiden (siehe Datenimport). Es gibt ist also kein einheitliches Datenmodell vorgeschrieben.",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Abfragen mit SPARQL</span>"
    ]
  },
  {
    "objectID": "architecture.html",
    "href": "architecture.html",
    "title": "Systemarchitektur",
    "section": "",
    "text": "Technik",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#technik",
    "href": "architecture.html#technik",
    "title": "Systemarchitektur",
    "section": "",
    "text": "Webserver (nginx)\nProperty-Graph Datenbanksystem (Neo4J)\nTriple-Store (Fuseki)\nSkripte in Python und NodeJS\nDocker",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#workflow",
    "href": "architecture.html#workflow",
    "title": "Systemarchitektur",
    "section": "Workflow",
    "text": "Workflow\nDer gesamte Prozess zur Integration von Daten in den Knowledge Graphen beinhaltet besteht aus folgenden Schritten:\n\nAnnahme, Prüfung und Bereinigung\nKonvertierung\nEinspielung\nImplementierung siehe https://github.com/nfdi4objects/n4o-property-graph\nAnreicherung\nBereitstellung\nNoch nicht umgesett\n\nEtwas genauer lässt sich der Prozess etwa wie in Abbildung 10.1 dargestellt veranschaulichen.\n\n\n\n\n\n\nflowchart LR\n    APIs[\"&lt;b&gt;APIs&lt;/b&gt;&lt;br/&gt;&lt;i&gt;repo: n4o-graph-apis&lt;/i&gt;&lt;br/&gt;&lt;i&gt;status: ready&lt;/i&gt;\"]\n    LIDO[\"&lt;b&gt;LIDO&lt;/b&gt;\"]\n    LIDOConverter[\"&lt;b&gt;LIDOConverter&lt;/b&gt;&lt;br/&gt;&lt;i&gt;tool: X3ML&lt;/i&gt;&lt;br/&gt;&lt;i&gt;repo: ?&lt;/i&gt;&lt;br/&gt;&lt;i&gt;status: prototype&lt;/i&gt;\"]\n    Property_Graph[\"&lt;b&gt;Property_Graph&lt;/b&gt;&lt;br/&gt;&lt;i&gt;status: prototype&lt;/i&gt;\"]\n    RDF[\"&lt;b&gt;RDF&lt;/b&gt;\"]\n    RDFConverter[\"&lt;b&gt;RDFConverter&lt;/b&gt;&lt;br/&gt;&lt;i&gt;status: planned&lt;/i&gt;&lt;br/&gt;&lt;i&gt;repo: ?&lt;/i&gt;\"]\n    Terminologies[\"&lt;b&gt;Terminologies&lt;/b&gt;&lt;br/&gt;&lt;i&gt;repo: n4o-terminologies&lt;/i&gt;&lt;br/&gt;&lt;i&gt;status: prototype&lt;/i&gt;\"]\n    TerminologyConverter[\"&lt;b&gt;TerminologyConverter&lt;/b&gt;&lt;br/&gt;&lt;i&gt;status: planned&lt;/i&gt;&lt;br/&gt;&lt;i&gt;repo: ?&lt;/i&gt;\"]\n    Triple_Store[\"&lt;b&gt;Triple_Store&lt;/b&gt;&lt;br/&gt;&lt;i&gt;status: prototype&lt;/i&gt;\"]\n    sources[\"&lt;b&gt;sources&lt;/b&gt;&lt;br/&gt;&lt;i&gt;repo: n4o-databases&lt;/i&gt;&lt;br/&gt;&lt;i&gt;status: prototype&lt;/i&gt;\"]\n    sources -- \"&lt;u&gt;pgraph&lt;/u&gt;\" --&gt; Property_Graph\n    sources --&gt; Triple_Store\n    sources --&gt; LIDO\n    sources --&gt; RDF\n    LIDO -- \"&lt;u&gt;n4o-import&lt;/u&gt;\" --&gt; LIDOConverter\n    LIDOConverter -- \"&lt;u&gt;pgraph&lt;/u&gt;\" --&gt; Property_Graph\n    RDF -- \"&lt;u&gt;n4o-import&lt;/u&gt;\" --&gt; RDFConverter\n    RDFConverter -- \"&lt;u&gt;load-rdf&lt;/u&gt;\" --&gt; Triple_Store\n    RDFConverter -- \"&lt;u&gt;pgraph&lt;/u&gt;\" --&gt; Property_Graph\n    Property_Graph -- \"&lt;u&gt;enrich&lt;/u&gt;\" --&gt; Property_Graph\n    LIDOConverter --&gt; RDFConverter\n    Property_Graph -- \"&lt;u&gt;Cypher&lt;/u&gt;\" --&gt; APIs\n    Triple_Store -- \"&lt;u&gt;SPARQL&lt;/u&gt;\" --&gt; APIs\n    Terminologies --&gt; TerminologyConverter\n    TerminologyConverter -- \"&lt;u&gt;load-rdf&lt;/u&gt;\" --&gt; Triple_Store\n    TerminologyConverter -- \"&lt;u&gt;pgraph&lt;/u&gt;\" --&gt; Property_Graph\n\n\n\n\n\nAbbildung 10.1: Datenfluss",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#annahme",
    "href": "architecture.html#annahme",
    "title": "Systemarchitektur",
    "section": "Annahme",
    "text": "Annahme\nZur Datenannahme, Prüfung und Bereinigung siehe https://github.com/nfdi4objects/n4o-import.\nDort findet sich unter anderem das offizielle XML-Schema für LIDO-Daten.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#konvertierung",
    "href": "architecture.html#konvertierung",
    "title": "Systemarchitektur",
    "section": "Konvertierung",
    "text": "Konvertierung\n\nLIDO\nLIDO-XML-Daten werden mit Hilfe von X3ML ins Property Graph Format konvertiert.\n\n\nRDF\nZur Konvertierung von RDF-Daten ins Property Graph Format dient das Skript rdf2cypher.py (wird derzeit überarbeitet), das eine Cypher-Datei (in Zukunkft CYPHERL und/oder PG-JSONL) ausgibt.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#einspielung",
    "href": "architecture.html#einspielung",
    "title": "Systemarchitektur",
    "section": "Einspielung",
    "text": "Einspielung\n\nRDF-Daten in den Property-Graph\nZum Einspielen der Cypher-Datei in eine Neo4J-Datenbank kann das Kommando cypher-shell verwendet werden, das im Neo4J-Docker-Container enthalten ist oder separat installiert werden kann.\nDa Neo4J aus dem Docker-Container nicht auf die Cypher-Datei zugreifen kann, muss ihr Inhalt per Pipe eingelesen werden:\n&lt;file.cypher | docker exec -t neo4j \\\n  cypher-shell -a &lt;ADDRESS&gt; -u &lt;USERNAME&gt; -p &lt;PASSWORD&gt;\nEin neuer Docker Container kann mit diesem Kommando erstellt werden. Ein Ordner für Volume muss bereits existieren.\ndocker run -d \\\n    --name=neo4j \\\n    --publish=7474:7474 --publish=7687:7687 \\\n    --env NEO4J_AUTH=none \\\n    --user $(id -u):$(id -g) \\\n    --volume=$cwd/data:/data \\\n    neo4j \n\n\nRDF-Daten\nSiehe https://github.com/nfdi4objects/n4o-import",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "architecture.html#anreicherung",
    "href": "architecture.html#anreicherung",
    "title": "Systemarchitektur",
    "section": "Anreicherung",
    "text": "Anreicherung\n\nExpansion der Klassenhierarchie\nDa Property-Graphen im Gegensatz zu RDF keine Inferenz-Regeln beinhalten und weil Inferenz-Regeln sowieso umständlich sind, werden die Daten im Property-Graphen expandiert. Grundlage ist ein eigener Property-Graph mit der Klassenhierarchie des CIDOC-CRM Datenmodell samt zwischenzeitlich umbenannter oder veralteter Klassen in der Datei crm-classes.pg (siehe SVG-Diagram). Der Graph aller Klassen enthält Informationen darüber welche Klassen sich aus einer anderen ergeben, z.B.\n\nE22_Man_Made_Object =&gt; E22_Human_Made_Object (renamedTo)\nE50_Date =&gt; E41_Appellation (replacedBy)\nE7_Activity=&gt; E5_Event (superClass)\n\nAus diesen Daten wird die Expansionstabelle crm-expand.txt erzeugt, z.B.:\n\nE22_Human_Made_Object =&gt; E22, E71, E70, E24 E77 und E1\n\nZum Ausführen der Expansion:\n./pg-expand-labels.py [Neo4j login file] &lt; crm-expand.txt\nOhne Konfigurationsdatei für Neo4J werden Cypher-Kommandos ausgegeben. Mit Konfiguration wird die Expansion in der betreffenden Neo4J-Datenbank ausgeführt.\nNach der Expansion ist die Abfrage nach allen Knoten mit einem bestimmten Label wie z.B. E22_Human_Made_Object möglich oder nach allen Knoten, die direkt oder indirekt er Klasse E22 angehören.\nDie Expansion ist auf gleiche Weise für andere Ontologien möglich, sofern diese auf CRM gemappt wurden.",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Systemarchitektur</span>"
    ]
  },
  {
    "objectID": "mappings.html",
    "href": "mappings.html",
    "title": "Mappings",
    "section": "",
    "text": "Mapping von Schemas\nDas einheitliche Datenmodell des Knowledge Graphen basiert auf CIDOC-CRM (siehe Datenbankschema). Werden in den gelieferten Daten andere Ontologien verwendet, so müssen diese auf CRM abgebildet werden. Die Abbildung geschieht bislang per Hand in Konfigurationsdateien. In Zukunft soll als Werkzeug hierfür auch Cocoda eingesetzt werden.\nNeben der Abbildung von verschiedenen Ontologien auf CRM ist es auch notwendig, unterschiedliche Modellierungsmöglichkeiten innerhalb von CRM auf ein Schema zu vereinheitlichen.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Mappings</span>"
    ]
  },
  {
    "objectID": "mappings.html#mapping-von-vokabularen",
    "href": "mappings.html#mapping-von-vokabularen",
    "title": "Mappings",
    "section": "Mapping von Vokabularen",
    "text": "Mapping von Vokabularen\nIn den gelieferten Daten werden Entäten wie Personen, Orte, Zeiträume, Materialien etc. auf unterschiedliche Art und Weise referenziert. Im Idealfall wird per Identifiern auf Normdateien verwiesen. Wenn unterschiedliche Normdateien für die gleichen Entitäten verwendet werden, sollten diese aufeinander gemappt werden. Als Werkzeug hierfür dient die Webanwendung Cocoda.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Mappings</span>"
    ]
  },
  {
    "objectID": "mappings.html#reconciliation",
    "href": "mappings.html#reconciliation",
    "title": "Mappings",
    "section": "Reconciliation",
    "text": "Reconciliation\nWerden Entitäten lediglich durch Zeichenketten referenziert (z.B. “Gold” zur Angabe des chemischen Elements Gold), so müssen diese Angaben möglichst auf kontrollierte Vokabulare mit entsprechenden Identifiern gemappt werden. Als technische Schnittstelle hierfür dient dazu die Reconciliation Service API. Wie weit die Erkennung von Entitäten aus Zeichenketten automatisiert ablaufen kann, hängt allerdings stark vom Kontext der Daten ab.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Mappings</span>"
    ]
  },
  {
    "objectID": "mappings.html#mapping-von-werten",
    "href": "mappings.html#mapping-von-werten",
    "title": "Mappings",
    "section": "Mapping von Werten",
    "text": "Mapping von Werten\nIn den gelieferten Daten kommen Werte mit unterschiedlichen Einheiten (Datumsangaben, Ortsangaben, Mengen, Gewichte und andere physische Maße…) vor. Diese sollten möglichst vereinheitlicht werden, damit Abfragen über den gesamten Datenbestand möglich sind.",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Mappings</span>"
    ]
  },
  {
    "objectID": "status.html",
    "href": "status.html",
    "title": "Status",
    "section": "",
    "text": "Property Graph\nFolgende Übersicht wird live per Cypher API erstellt.\ncypherNodesCount = await cypherQuery(\"MATCH () RETURN count(*) as count\")\ncypherEdgesCount = await cypherQuery(\"MATCH ()-[]-&gt;() RETURN count(*) as count\")\nsparqlTripleCount = await sparqlQuery(\"SELECT (COUNT(*) as ?count) { GRAPH ?graph { ?s ?p ?o } }\")",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Status</span>"
    ]
  },
  {
    "objectID": "status.html#property-graph",
    "href": "status.html#property-graph",
    "title": "Status",
    "section": "",
    "text": "Anzahl von Knoten: \nAnzahl von Kanten:",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Status</span>"
    ]
  },
  {
    "objectID": "status.html#triple-store",
    "href": "status.html#triple-store",
    "title": "Status",
    "section": "Triple Store",
    "text": "Triple Store\n\nAnzahl von Tripel:",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Status</span>"
    ]
  },
  {
    "objectID": "status.html#datenquellen",
    "href": "status.html#datenquellen",
    "title": "Status",
    "section": "Datenquellen",
    "text": "Datenquellen\nDer Status des Import aus Datenquellen ist noch nicht öffentlich zugänglich.",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Status</span>"
    ]
  }
]